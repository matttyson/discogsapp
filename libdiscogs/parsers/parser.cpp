/* clang-format off */
/* Autogenerated.  Do not edit. */

#include <rapidjson/rapidjson.h>
#include <rapidjson/reader.h>
#include "parser_common.hpp"
#include "basic_information.hpp"
#include "paginate.hpp"
#include "folder_releases.hpp"
#include "folder_releases_parser.hpp"
#include "wantlist.hpp"
#include "wantlist_parser.hpp"
#include "collection.hpp"
#include "collection_parser.hpp"

namespace discogs {
namespace parser {
enum class DataType : unsigned short {
	START,
	ARRAY,
	OBJECT,
	DATA,
	NONE,
};


enum class StackKey : unsigned short {
	anv,
	artists,
	basic_information,
	catno,
	count,
	cover_image,
	date_added,
	descriptions,
	entity_type,
	entity_type_name,
	field_id,
	first,
	folder_id,
	folders,
	formats,
	id,
	instance_id,
	items,
	join,
	labels,
	last,
	name,
	next,
	notes,
	page,
	pages,
	pagination,
	per_page,
	prev,
	qty,
	rating,
	releases,
	resource_url,
	role,
	text,
	thumb,
	title,
	tracks,
	urls,
	value,
	wants,
	year,
	UNKNOWN
};

StackKey StackList::parent()
{
	for(auto it = m_location.crbegin();
		it != m_location.crend();
		it++)
	{
		if(it->key() != StackKey::UNKNOWN){
			return it->key();
		}
	}
	return StackKey::UNKNOWN;
}


class json_keys {
public:
	constexpr json_keys(const char_t *theKey, int theLength, StackKey theCode)
		:m_key(theKey), m_length(theLength), m_code(theCode) {}
	constexpr const char_t* key() const { return m_key; }
	constexpr rapidjson::SizeType length() const { return m_length; }
	constexpr StackKey code() const { return m_code; }
private:
	const char_t *m_key;
	const rapidjson::SizeType m_length;
	const StackKey m_code;
};

#ifdef RJSP_WIDE_CHAR
#define _RJSP_WIDE(x) L ## x
#else
#define _RJSP_WIDE(x) x
#endif



constexpr static json_keys keylist[] = {
	{_RJSP_WIDE("anv"), 3, StackKey::anv},
	{_RJSP_WIDE("artists"), 7, StackKey::artists},
	{_RJSP_WIDE("basic_information"), 17, StackKey::basic_information},
	{_RJSP_WIDE("catno"), 5, StackKey::catno},
	{_RJSP_WIDE("count"), 5, StackKey::count},
	{_RJSP_WIDE("cover_image"), 11, StackKey::cover_image},
	{_RJSP_WIDE("date_added"), 10, StackKey::date_added},
	{_RJSP_WIDE("descriptions"), 12, StackKey::descriptions},
	{_RJSP_WIDE("entity_type"), 11, StackKey::entity_type},
	{_RJSP_WIDE("entity_type_name"), 16, StackKey::entity_type_name},
	{_RJSP_WIDE("field_id"), 8, StackKey::field_id},
	{_RJSP_WIDE("first"), 5, StackKey::first},
	{_RJSP_WIDE("folder_id"), 9, StackKey::folder_id},
	{_RJSP_WIDE("folders"), 7, StackKey::folders},
	{_RJSP_WIDE("formats"), 7, StackKey::formats},
	{_RJSP_WIDE("id"), 2, StackKey::id},
	{_RJSP_WIDE("instance_id"), 11, StackKey::instance_id},
	{_RJSP_WIDE("items"), 5, StackKey::items},
	{_RJSP_WIDE("join"), 4, StackKey::join},
	{_RJSP_WIDE("labels"), 6, StackKey::labels},
	{_RJSP_WIDE("last"), 4, StackKey::last},
	{_RJSP_WIDE("name"), 4, StackKey::name},
	{_RJSP_WIDE("next"), 4, StackKey::next},
	{_RJSP_WIDE("notes"), 5, StackKey::notes},
	{_RJSP_WIDE("page"), 4, StackKey::page},
	{_RJSP_WIDE("pages"), 5, StackKey::pages},
	{_RJSP_WIDE("pagination"), 10, StackKey::pagination},
	{_RJSP_WIDE("per_page"), 8, StackKey::per_page},
	{_RJSP_WIDE("prev"), 4, StackKey::prev},
	{_RJSP_WIDE("qty"), 3, StackKey::qty},
	{_RJSP_WIDE("rating"), 6, StackKey::rating},
	{_RJSP_WIDE("releases"), 8, StackKey::releases},
	{_RJSP_WIDE("resource_url"), 12, StackKey::resource_url},
	{_RJSP_WIDE("role"), 4, StackKey::role},
	{_RJSP_WIDE("text"), 4, StackKey::text},
	{_RJSP_WIDE("thumb"), 5, StackKey::thumb},
	{_RJSP_WIDE("title"), 5, StackKey::title},
	{_RJSP_WIDE("tracks"), 6, StackKey::tracks},
	{_RJSP_WIDE("urls"), 4, StackKey::urls},
	{_RJSP_WIDE("value"), 5, StackKey::value},
	{_RJSP_WIDE("wants"), 5, StackKey::wants},
	{_RJSP_WIDE("year"), 4, StackKey::year},
};
#undef _RJSP_WIDE

constexpr int keylist_size = 42;

template <typename T>
static int my_strcmp(const T *str1, const T *str2)
{
	if constexpr (sizeof(T) == sizeof(char)){
		return ::strcmp(str1, str2);
	}
	else if constexpr (sizeof(T) == sizeof(wchar_t)) {
		return ::wcscmp(str1, str2);
	}
}

static StackKey bsearch_keys(
	const char_t *key,
	const json_keys json_keylist[],
	int keylist_count)
{
	int left = 0;
	int right = keylist_count;
	int middle;

	while(left <= right){
		middle = left + (right - left) / 2;
		int rc = my_strcmp(key, json_keylist[middle].key());

		if(rc == 0){
			return json_keylist[middle].code();
		}
		else if(rc > 0){
			left = middle + 1;
		}
		else {
			right = middle - 1;
		}
	}

	return StackKey::UNKNOWN;
}

} // namespace discogs
} // namespace parser

namespace discogs {
namespace parser {
namespace folder_releases {

parser::parser()
	:
		m_currentKey(StackKey::UNKNOWN)
{}

bool parser::Number(int i)
{
	const StackKey parent = m_list.parent();

	switch(m_currentKey){
		case StackKey::field_id:
			release_.back().basic_information_.notes_.back().field_id = i;
			break;
		case StackKey::folder_id:
			release_.back().basic_information_.folder_id = i;
			break;
		case StackKey::id:
			{
				switch(parent){
				case StackKey::releases:
					release_.back().id = i;
					break;
				case StackKey::basic_information:
					release_.back().basic_information_.id = i;
					break;
				case StackKey::labels:
					release_.back().basic_information_.label_.back().id = i;
					break;
				case StackKey::artists:
					release_.back().basic_information_.artist_.back().id = i;
					break;
				default:
					return false;
				}
			}
			break;
		case StackKey::instance_id:
			release_.back().instance_id = i;
			break;
		case StackKey::items:
			pages.items = i;
			break;
		case StackKey::page:
			pages.page = i;
			break;
		case StackKey::pages:
			pages.pages = i;
			break;
		case StackKey::per_page:
			pages.per_page = i;
			break;
		case StackKey::rating:
			release_.back().rating = i;
			break;
		case StackKey::year:
			release_.back().basic_information_.year = i;
			break;
		default:
			return false;
	}

	return true;
}

bool parser::Null()
{
	return false;
}

bool parser::Bool(bool b)
{
	return false;
}

bool parser::Int(int i)
{
	return Number((int)i);
}

bool parser::Uint(unsigned i)
{
	return Number((int)i);
}

bool parser::Int64(int64_t i)
{
	return false;
}

bool parser::Uint64(uint64_t i)
{
	return false;
}

bool parser::Double(double d)
{
	return false;
}

bool parser::RawNumber(const Ch * str, rapidjson::SizeType length, bool copy)
{
	return false;
}

bool parser::String(const Ch* str, rapidjson::SizeType length, bool copy)
{
	if(length == 0){
		return true;
	}
	const StackKey parent = m_list.parent();

	switch(m_currentKey){
		case StackKey::anv:
			release_.back().basic_information_.artist_.back().anv.assign(str, length);
			break;
		case StackKey::catno:
			release_.back().basic_information_.label_.back().catno.assign(str, length);
			break;
		case StackKey::cover_image:
			release_.back().basic_information_.cover_image.assign(str, length);
			break;
		case StackKey::date_added:
			release_.back().date_added.assign(str, length);
			break;
		case StackKey::descriptions:
			release_.back().basic_information_.format_.back().descriptions.emplace_back(str, length);
			break;
		case StackKey::entity_type:
			release_.back().basic_information_.label_.back().entity_type.assign(str, length);
			break;
		case StackKey::entity_type_name:
			release_.back().basic_information_.label_.back().entity_type_name.assign(str, length);
			break;
		case StackKey::first:
			pages.links.first.assign(str, length);
			break;
		case StackKey::join:
			release_.back().basic_information_.artist_.back().join.assign(str, length);
			break;
		case StackKey::last:
			pages.links.last.assign(str, length);
			break;
		case StackKey::name:
			{
				switch(parent){
				case StackKey::labels:
					release_.back().basic_information_.label_.back().name.assign(str, length);
					break;
				case StackKey::formats:
					release_.back().basic_information_.format_.back().name.assign(str, length);
					break;
				case StackKey::artists:
					release_.back().basic_information_.artist_.back().name.assign(str, length);
					break;
				default:
					return false;
				}
			}
			break;
		case StackKey::next:
			pages.links.next.assign(str, length);
			break;
		case StackKey::prev:
			pages.links.prev.assign(str, length);
			break;
		case StackKey::qty:
			release_.back().basic_information_.format_.back().qty.assign(str, length);
			break;
		case StackKey::resource_url:
			{
				switch(parent){
				case StackKey::basic_information:
					release_.back().basic_information_.resource_url.assign(str, length);
					break;
				case StackKey::labels:
					release_.back().basic_information_.label_.back().resource_url.assign(str, length);
					break;
				case StackKey::artists:
					release_.back().basic_information_.artist_.back().resource_url.assign(str, length);
					break;
				default:
					return false;
				}
			}
			break;
		case StackKey::role:
			release_.back().basic_information_.artist_.back().role.assign(str, length);
			break;
		case StackKey::text:
			release_.back().basic_information_.format_.back().text.assign(str, length);
			break;
		case StackKey::thumb:
			release_.back().basic_information_.thumb.assign(str, length);
			break;
		case StackKey::title:
			release_.back().basic_information_.title.assign(str, length);
			break;
		case StackKey::tracks:
			release_.back().basic_information_.artist_.back().tracks.assign(str, length);
			break;
		case StackKey::value:
			release_.back().basic_information_.notes_.back().value.assign(str, length);
			break;
		default:
			return false;
	}

	return true;
}

bool parser::Key(const Ch* str, rapidjson::SizeType length, bool copy)
{
	m_currentKey = bsearch_keys(str, keylist, keylist_size);
	if(m_currentKey == StackKey::UNKNOWN){
		return false;
	}
	return true;
}

bool parser::StartObject()
{
	if (m_currentKey == StackKey::UNKNOWN) {
		// We're probably in an array, probably.
		m_currentKey = m_list.parent();
	}

	switch(m_currentKey){
	case StackKey::releases:
		release_.emplace_back();
		break;
	case StackKey::labels:
		release_.back().basic_information_.label_.emplace_back();
		break;
	case StackKey::formats:
		release_.back().basic_information_.format_.emplace_back();
		break;
	case StackKey::artists:
		release_.back().basic_information_.artist_.emplace_back();
		break;
	case StackKey::notes:
		release_.back().basic_information_.notes_.emplace_back();
		break;
	}

	m_list.add(m_currentKey, DataType::OBJECT);

	return true;
}

bool parser::EndObject(rapidjson::SizeType memberCount)
{
	m_list.pop();

	m_currentKey = StackKey::UNKNOWN;
	return true;
}

bool parser::StartArray()
{
	if (m_currentKey == StackKey::UNKNOWN) {
		m_currentKey = m_list.parent();
	}

	m_list.add(m_currentKey, DataType::ARRAY);

	return true;
}

bool parser::EndArray(rapidjson::SizeType elementCount)
{
	m_list.pop();

	m_currentKey = StackKey::UNKNOWN;

	return true;
}

} // namespace discogs
} // namespace parser
} // namespace folder_releases


namespace discogs {
namespace parser {
namespace wantlist {

parser::parser()
	:
		m_currentKey(StackKey::UNKNOWN)
{}

bool parser::Number(int i)
{
	const StackKey parent = m_list.parent();

	switch(m_currentKey){
		case StackKey::field_id:
			wants_.back().basic_information_.notes_.back().field_id = i;
			break;
		case StackKey::folder_id:
			wants_.back().basic_information_.folder_id = i;
			break;
		case StackKey::id:
			{
				switch(parent){
				case StackKey::wants:
					wants_.back().id = i;
					break;
				case StackKey::basic_information:
					wants_.back().basic_information_.id = i;
					break;
				case StackKey::labels:
					wants_.back().basic_information_.label_.back().id = i;
					break;
				case StackKey::artists:
					wants_.back().basic_information_.artist_.back().id = i;
					break;
				default:
					return false;
				}
			}
			break;
		case StackKey::items:
			pages.items = i;
			break;
		case StackKey::page:
			pages.page = i;
			break;
		case StackKey::pages:
			pages.pages = i;
			break;
		case StackKey::per_page:
			pages.per_page = i;
			break;
		case StackKey::rating:
			wants_.back().rating = i;
			break;
		case StackKey::year:
			wants_.back().basic_information_.year = i;
			break;
		default:
			return false;
	}

	return true;
}

bool parser::Null()
{
	return false;
}

bool parser::Bool(bool b)
{
	return false;
}

bool parser::Int(int i)
{
	return Number((int)i);
}

bool parser::Uint(unsigned i)
{
	return Number((int)i);
}

bool parser::Int64(int64_t i)
{
	return false;
}

bool parser::Uint64(uint64_t i)
{
	return false;
}

bool parser::Double(double d)
{
	return false;
}

bool parser::RawNumber(const Ch * str, rapidjson::SizeType length, bool copy)
{
	return false;
}

bool parser::String(const Ch* str, rapidjson::SizeType length, bool copy)
{
	if(length == 0){
		return true;
	}
	const StackKey parent = m_list.parent();

	switch(m_currentKey){
		case StackKey::anv:
			wants_.back().basic_information_.artist_.back().anv.assign(str, length);
			break;
		case StackKey::catno:
			wants_.back().basic_information_.label_.back().catno.assign(str, length);
			break;
		case StackKey::cover_image:
			wants_.back().basic_information_.cover_image.assign(str, length);
			break;
		case StackKey::date_added:
			wants_.back().date_added.assign(str, length);
			break;
		case StackKey::descriptions:
			wants_.back().basic_information_.format_.back().descriptions.emplace_back(str, length);
			break;
		case StackKey::entity_type:
			wants_.back().basic_information_.label_.back().entity_type.assign(str, length);
			break;
		case StackKey::entity_type_name:
			wants_.back().basic_information_.label_.back().entity_type_name.assign(str, length);
			break;
		case StackKey::first:
			pages.links.first.assign(str, length);
			break;
		case StackKey::join:
			wants_.back().basic_information_.artist_.back().join.assign(str, length);
			break;
		case StackKey::last:
			pages.links.last.assign(str, length);
			break;
		case StackKey::name:
			{
				switch(parent){
				case StackKey::labels:
					wants_.back().basic_information_.label_.back().name.assign(str, length);
					break;
				case StackKey::formats:
					wants_.back().basic_information_.format_.back().name.assign(str, length);
					break;
				case StackKey::artists:
					wants_.back().basic_information_.artist_.back().name.assign(str, length);
					break;
				default:
					return false;
				}
			}
			break;
		case StackKey::next:
			pages.links.next.assign(str, length);
			break;
		case StackKey::notes:
			wants_.back().notes.assign(str, length);
			break;
		case StackKey::prev:
			pages.links.prev.assign(str, length);
			break;
		case StackKey::qty:
			wants_.back().basic_information_.format_.back().qty.assign(str, length);
			break;
		case StackKey::resource_url:
			{
				switch(parent){
				case StackKey::wants:
					wants_.back().resource_url.assign(str, length);
					break;
				case StackKey::basic_information:
					wants_.back().basic_information_.resource_url.assign(str, length);
					break;
				case StackKey::labels:
					wants_.back().basic_information_.label_.back().resource_url.assign(str, length);
					break;
				case StackKey::artists:
					wants_.back().basic_information_.artist_.back().resource_url.assign(str, length);
					break;
				default:
					return false;
				}
			}
			break;
		case StackKey::role:
			wants_.back().basic_information_.artist_.back().role.assign(str, length);
			break;
		case StackKey::text:
			wants_.back().basic_information_.format_.back().text.assign(str, length);
			break;
		case StackKey::thumb:
			wants_.back().basic_information_.thumb.assign(str, length);
			break;
		case StackKey::title:
			wants_.back().basic_information_.title.assign(str, length);
			break;
		case StackKey::tracks:
			wants_.back().basic_information_.artist_.back().tracks.assign(str, length);
			break;
		case StackKey::value:
			wants_.back().basic_information_.notes_.back().value.assign(str, length);
			break;
		default:
			return false;
	}

	return true;
}

bool parser::Key(const Ch* str, rapidjson::SizeType length, bool copy)
{
	m_currentKey = bsearch_keys(str, keylist, keylist_size);
	if(m_currentKey == StackKey::UNKNOWN){
		return false;
	}
	return true;
}

bool parser::StartObject()
{
	if (m_currentKey == StackKey::UNKNOWN) {
		// We're probably in an array, probably.
		m_currentKey = m_list.parent();
	}

	switch(m_currentKey){
	case StackKey::wants:
		wants_.emplace_back();
		break;
	case StackKey::labels:
		wants_.back().basic_information_.label_.emplace_back();
		break;
	case StackKey::formats:
		wants_.back().basic_information_.format_.emplace_back();
		break;
	case StackKey::artists:
		wants_.back().basic_information_.artist_.emplace_back();
		break;
	case StackKey::notes:
		wants_.back().basic_information_.notes_.emplace_back();
		break;
	}

	m_list.add(m_currentKey, DataType::OBJECT);

	return true;
}

bool parser::EndObject(rapidjson::SizeType memberCount)
{
	m_list.pop();

	m_currentKey = StackKey::UNKNOWN;
	return true;
}

bool parser::StartArray()
{
	if (m_currentKey == StackKey::UNKNOWN) {
		m_currentKey = m_list.parent();
	}

	m_list.add(m_currentKey, DataType::ARRAY);

	return true;
}

bool parser::EndArray(rapidjson::SizeType elementCount)
{
	m_list.pop();

	m_currentKey = StackKey::UNKNOWN;

	return true;
}

} // namespace discogs
} // namespace parser
} // namespace wantlist


namespace discogs {
namespace parser {
namespace collection {

parser::parser()
	:
		m_currentKey(StackKey::UNKNOWN)
{}

bool parser::Number(int i)
{
	const StackKey parent = m_list.parent();

	switch(m_currentKey){
		case StackKey::count:
			folders_.back().count = i;
			break;
		case StackKey::id:
			folders_.back().id = i;
			break;
		default:
			return false;
	}

	return true;
}

bool parser::Null()
{
	return false;
}

bool parser::Bool(bool b)
{
	return false;
}

bool parser::Int(int i)
{
	return Number((int)i);
}

bool parser::Uint(unsigned i)
{
	return Number((int)i);
}

bool parser::Int64(int64_t i)
{
	return false;
}

bool parser::Uint64(uint64_t i)
{
	return false;
}

bool parser::Double(double d)
{
	return false;
}

bool parser::RawNumber(const Ch * str, rapidjson::SizeType length, bool copy)
{
	return false;
}

bool parser::String(const Ch* str, rapidjson::SizeType length, bool copy)
{
	if(length == 0){
		return true;
	}
	const StackKey parent = m_list.parent();

	switch(m_currentKey){
		case StackKey::name:
			folders_.back().name.assign(str, length);
			break;
		case StackKey::resource_url:
			folders_.back().resource_url.assign(str, length);
			break;
		default:
			return false;
	}

	return true;
}

bool parser::Key(const Ch* str, rapidjson::SizeType length, bool copy)
{
	m_currentKey = bsearch_keys(str, keylist, keylist_size);
	if(m_currentKey == StackKey::UNKNOWN){
		return false;
	}
	return true;
}

bool parser::StartObject()
{
	if (m_currentKey == StackKey::UNKNOWN) {
		// We're probably in an array, probably.
		m_currentKey = m_list.parent();
	}

	switch(m_currentKey){
	case StackKey::folders:
		folders_.emplace_back();
		break;
	}

	m_list.add(m_currentKey, DataType::OBJECT);

	return true;
}

bool parser::EndObject(rapidjson::SizeType memberCount)
{
	m_list.pop();

	m_currentKey = StackKey::UNKNOWN;
	return true;
}

bool parser::StartArray()
{
	if (m_currentKey == StackKey::UNKNOWN) {
		m_currentKey = m_list.parent();
	}

	m_list.add(m_currentKey, DataType::ARRAY);

	return true;
}

bool parser::EndArray(rapidjson::SizeType elementCount)
{
	m_list.pop();

	m_currentKey = StackKey::UNKNOWN;

	return true;
}

} // namespace discogs
} // namespace parser
} // namespace collection

/* clang-format on */
